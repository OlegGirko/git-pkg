#!/bin/bash
# gitpkg common shell functions and variables

# DISTRO should go to some config file
DISTRO=mer

pkg_branch=pkg-$DISTRO

ME=$(basename $0)

# Function for verbose output
log(){
    [[ "x$_V" == "x1" ]] && echo "$@"
}

# Input: $pkgdir
# Output: $ver  $rel
get_info_from_packaging() {
    _pkgdir=${1:-.}
    # See if there's a yaml or a .spec
    _vrfile=$(cd $_pkgdir; find . -maxdepth 1 -name '*yaml' -print -quit)
    _vrfile=${vrfile:-$(cd $_pkgdir; find . -maxdepth 1 -name '*spec' -print -quit)}
    if [[ -f $_pkgdir/$_vrfile ]]; then
	ver=$(grep Version: $_pkgdir/$_vrfile | cut -f2 -d: | tr -d '[:space:]')
	rel=$(grep Release: $_pkgdir/$_vrfile | cut -f2 -d: | tr -d '[:space:]')
	name=$(grep Name: $_pkgdir/$_vrfile | cut -f2 -d: | tr -d '[:space:]')
	log "Found Version/Release: $ver-$rel in the packaging"
    fi
}

# Input: 
# Output: 
# http://stackoverflow.com/a/3879077/337649

count_commits() {
    git rev-list $1..$2 -- | wc -l
}

git_tag_cleanly() {
    tag=$1
    old=$(git rev-list -1 $1 2>/dev/null || echo none)
    git tag -f $@
    tag_cleanup_list+=" $1:$old"
}

cleanup(){
    # If there is no .git directory there is nothing to cleanup.
    [[ -d .git ]] || return

    if [[ $tag_cleanup_list ]] ; then
	echo "cleaning up tags: $tag_cleanup_list"
	for tagpair in $tag_cleanup_list; do
	    eval IFS=: read tag sha1 <<< $tagpair
	    if [[ $sha1 == "none" ]]; then
		git tag -d $tag
	    else
		git tag -f $tag $sha1
	    fi
	done
    fi
    if [[ $branch_cleanup_list ]]; then
	echo "cleaning up branches: $branch_cleanup_list"
	for branch in $branch_cleanup_list; do
	    git branch -D $branch
	done
    fi
}

# If the first arg is 'usage' then usage() is called right before exit
fatal() {
    local usage=
    if [[ $1 == "usage" ]]; then
	shift
	usage=1
    fi
    if [[ $1 ]]; then
	echo "ERROR: $@"
    else # support fatal << EOF
	cat
    fi
    [[ $usage ]] && usage
    exit 1
}

# Setup rpm dir if not present
# optionally supply a branch to checkout to rpm/
ensure_rpm_subdir() {

    local rel_git_dir=../../.git
    local rpmdir=./rpm
    local branch=$1

    mkdir -p "$rpmdir/.git" || fatal "unable to create git repo in \"$rpmdir\"!"

    # From https://github.com/cypher/dotfiles/blob/master/bin/git-new-workdir
    #
    # create the links to the original repo. explicitly exclude index,
    # HEAD and logs/HEAD from the list since they are purely related
    # to the current working directory, and should not be shared.
    [[ -e $rpmdir/.git/main_git_repo ]] && fatal "rpm/.git is already a tracking rpm directory"
    ln -s $rel_git_dir $rpmdir/.git/main_git_repo
    for x in config refs logs/refs objects info hooks packed-refs remotes rr-cache svn; do
	case $x in
	    */*)
		mkdir -p "$(dirname "$rpmdir/.git/$x")"
		ln -s "../main_git_repo/$x" "$rpmdir/.git/$x" ;;
	    *)
		ln -s "main_git_repo/$x" "$rpmdir/.git/$x" ;;
	esac
    done

    # now checkout rpm/
    if [[ $branch ]]; then (
	    cd "$rpmdir"
	    cp "$rel_git_dir/HEAD" .git/HEAD
	    git checkout -f $branch
	)
    fi
}

export GIT_AUTHOR_EMAIL=${GIT_AUTHOR_EMAIL:-$(git config user.email)}
export GIT_AUTHOR_NAME=${GIT_AUTHOR_NAME:-$(git config user.name)}
